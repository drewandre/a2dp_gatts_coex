diff --git a/components/esp32/esp_timer_esp32.c b/components/esp32/esp_timer_esp32.c
index a62930d..f583c10 100644
--- a/components/esp32/esp_timer_esp32.c
+++ b/components/esp32/esp_timer_esp32.c
@@ -216,7 +216,7 @@ void IRAM_ATTR esp_timer_impl_set_alarm(uint64_t timestamp)
     // Note that if by the time we update ALARM_REG, COUNT_REG value is higher,
     // interrupt will not happen for another ALARM_OVERFLOW_VAL timer ticks,
     // so need to check if alarm value is too close in the future (e.g. <2 us away).
-    const int32_t offset = s_timer_ticks_per_us * 2;
+    int32_t offset = s_timer_ticks_per_us * 2;
     do {
         // Adjust current time if overflow has happened
         if (timer_overflow_happened()) {
@@ -236,7 +236,13 @@ void IRAM_ATTR esp_timer_impl_set_alarm(uint64_t timestamp)
             alarm_reg_val = (uint32_t) compare_val;
         }
         REG_WRITE(FRC_TIMER_ALARM_REG(1), alarm_reg_val);
-    } while (REG_READ(FRC_TIMER_ALARM_REG(1)) <= REG_READ(FRC_TIMER_COUNT_REG(1)));
+        int64_t delta = REG_READ(FRC_TIMER_ALARM_REG(1)) - REG_READ(FRC_TIMER_COUNT_REG(1));
+        if (delta <= 0) {
+            offset += abs((int)delta) + s_timer_ticks_per_us * 2;
+        } else {
+            break;
+        }
+    } while (1);
     portEXIT_CRITICAL_SAFE(&s_time_update_lock);
 }
 
